# 08. Understanding View Encapsulation

## What is View Encapsulation

在應用程式中，當新增伺服器或藍圖時，出現了一些變化。藍圖中新增了一個伺服器，並且頂部的 `<p>` 標籤不再是藍色的了。這是因為在 `app.component.css` 檔案中，我們定義了 `<p>` 標籤應該是藍色的文字。然而，這兩個 `<p>` 標籤已經移動了，它們不再是 `app.component` 的一部分。

這可能讓人感到困惑，因為根據 CSS 的運作方式，我們只需在 CSS 檔案中定義規則，它就會套用到整個文件中的相應元素。但這裡的情況並非如此，這是因為 Angular 強制執行了這種行為，這不是瀏覽器的預設行為。

雖然這些 CSS 檔案的目的是為它們所屬的元件封裝樣式，但這並不是預設行為，而是 Angular 提供的行為。這是一個很棒的特性，它確保我們在 CSS 檔案中定義的任何樣式只應用於相應的元件。

然而，這也意味著我們需要將相同的藍色設定複製到其他需要使用它的元件中。儘管我們可能並不打算在 `cockpit` 中使用它，但我們需要將它複製到 `server` 元件中。這樣，如果進行更改、重新載入並輸入內容，然後新增一個新的藍圖，你將看到文字再次變成藍色。

如果檢查開發者工具中的文本，你會注意到在樣式中，我們明確地指定了藍色，但卻沒有作用。選擇器已經改變，我們只是在樣式中寫了 `p`，而不是 `<p>` 標籤，並附加了一個奇怪的屬性 `_ngcontent-ejo-2`。

這就是為什麼這個樣式只應用於具有特定屬性的 `<p>` 標籤的原因。在 `app-cockpit` 中，有另一個位於 `div` 元素中的 `<p>` 標籤，它

具有不同的屬性 `_ngcontent-ejo1`。因此，樣式並未應用於此 `<p>` 標籤。

這些奇怪的屬性是由 Angular 自動應用於特定元素的，它強制執行這種樣式封裝行為。對於每個元件，它都使用不同的唯一屬性名稱，例如 `ejo-1`、`ejo-0` 和 `ejo-2`。這樣做的目的是確保一旦你更改了樣式選擇器，它將自動為該元件定義的所有樣式添加這個屬性選擇器，這些樣式只應用於該元件的元素。

這就是 Angular 強制執行這種行為的方式，它有點像模擬影子 DOM 的作用。影子 DOM 是一種不被所有瀏覽器支援的技術，它允許為每個元素指定樣式。Angular 通過這種方式模擬了影子 DOM，這也是 Angular 中視圖封裝的預設行為。

## Override View Encapsulation

現在你知道 Angular 如何封裝樣式，但現在你可以覆寫這種封裝。 Angular 提供了三種不同的封裝策略：

1. **`Emulated`**：這是預設策略，它模擬了影子 DOM 的行為，並為每個元件添加了「唯一的」屬性選擇器。這是一種很好的策略，因為它確保樣式只應用於它們所屬的元件，但也因此，如果你想在多個元件中使用相同的 CSS 樣式，就必須在不同元件中複製 CSS 樣式。
2. **`None`**：這是另一種策略，它不封裝樣式，而是將它們應用於整個應用程式。 這意味著如果你在 `app.component.css` 檔案中定義了一些樣式，它們將應用於整個應用程式。 如果你想要一些**全域**樣式，這是一種很好的策略，但它也可能導致一些問題，因為你可能會意外地覆蓋其他元件中的樣式。
3. **`Native`**：這是一種新的策略，本地模式使用了 Shadow DOM 技術。這應該會給你與模擬模式相同的結果，但只在支援的瀏覽器中有效。如果不支援，則會回退到 `Emulated` 策略。這是一種很好的策略，因為它使用瀏覽器的本機機制，但它也可能導致一些問題，因為它可能會覆寫其他元件中的樣式。

而你可以在 `@Component` 標記中使用 `encapsulation` 屬性來指定它們：

- [`server-element.component.ts`](../../cmp-databinding/src/app/server-element/server-element.component.ts)

```ts
import { ..., ViewEncapsulation } from '@angular/core';
...
@Component({
  ...
  encapsulation: ViewEncapsulation.Emulated // None, Native
})
export class ServerElementComponent implements OnInit { ... }
```

大多數情況下，建議選擇 **`Emulated`** 模式，但你也可以切換到無或本地模式。重要的是知道你可以更改封裝行為。這是一個方便的工具，確保元件只接收你為其定義的樣式，但可以被覆寫。